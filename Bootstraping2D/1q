#ifndef _LINE
#define _LINE
#include "Buffer/Buffer.hpp"
#include "Point.hpp"
#include <cstdio>
template <class T, class E> class Line {
public:
  constexpr static const float step = 0.001;
  // static void renderNaiveLine(Buffer<T> &indices, Buffer<E> &vertices, Point
  // p1,
  //                            Point p2) {
  //  int i = 0;
  //  float dx = p2.x - p1.x;
  //  float dy = p2.y - p1.y;
  //  float m, b, x, y;
  //  x = p1.x;
  //  y = p1.y;
  //  if (p1.x == p2.x) {
  //    if (p1.y > p2.y) {
  //      float temp = p1.y;
  //      p1.y = p2.y;
  //      p2.y = temp;
  //    }
  //    y = p1.y;
  //    while (y < p2.y) {
  //      y += step;
  //      indices.push(i);
  //      vertices.push_point(*new Point(x, y));
  //      i++;
  //    }
  //  } else {
  //    if (p1.x < p2.x) {
  //      Point temp = p1;
  //      p1 = temp;
  //      temp = p2;
  //    }
  //    while (x < p2.x) {
  //      y = p1.y + (dy / dx) * (x - p1.x);
  //      x += step;
  //      indices.push(i);
  //      vertices.push_point(*new Point(x, y));
  //      i++;
  //    }
  //  }
  //}
  // static void renderNaiveLine(Buffer<T> &indices, Buffer<E> &vertices, Point
  // p1,
  //                            Point p2) {
  //  // o swap
  //  int i = 0;
  //  float m, b, x, y;
  //  if (p1.x > p2.x) {
  //    swap(&p1.x, &p2.x);
  //  }
  //  if (p1.y < p2.y) {
  //    swap(&p1.y, &p2.y);
  //  }
  //  float dx = p2.x - p1.x;
  //  float dy = p2.y - p1.y;
  //  x = p1.x;
  //  y = p1.y;
  //  printf("x: %f, y: %f\n", x, y);
  //  if (p1.x == p2.x) {
  //    while (y < p2.y) {
  //      indices.push(i);
  //      vertices.push_point(*new Point(x, y));
  //      y += step;
  //      i++;
  //    }
  //  } else if (p1.y == p2.y) {
  //    while (x < p2.x) {
  //      indices.push(i);
  //      vertices.push_point(*new Point(x, y));
  //      x += step;
  //      i++;
  //    }
  //  } else {
  //    m = dy / dx;
  //    b = p1.y - m * p1.x;
  //    printf("b: %f\n", b);
  //    printf("m: %f\n", m);
  //    while (y > p2.y) {
  //      x = (y - b) / m;
  //      indices.push(i);
  //      vertices.push_point(*new Point(x, y));
  //      y -= step;
  //      i++;
  //    }
  //  }
  //}

  // static void renderNaiveLine(Buffer<T> &indices, Buffer<E> &vertices, Point
  // p1,
  //                             Point p2) {
  //   // o swap
  //   int i = 0;
  //   float m, b, x, y;
  //   // if (p1.x > p2.x) {
  //   //  swap(&p1.x, &p2.x);
  //   //}
  //   // if (p1.y < p2.y) {
  //   //  swap(&p1.y, &p2.y);
  //   //}
  //   float dx = p2.x - p1.x;
  //   float dy = p2.y - p1.y;
  //   x = p1.x;
  //   y = p1.y;
  //   if (p1.x == p2.x) {
  //     if (p1.y > p2.y) {
  //       swap(&p1.y, &p2.y);
  //     }
  //     while (y < p2.y) {
  //       indices.push(i);
  //       vertices.push_point(*new Point(x, y));
  //       y += step;
  //       i++;
  //     }
  //   } else if (p1.y == p2.y) {
  //     if (p1.x > p2.x) {
  //       swap(&p1.x, &p2.x);
  //     }
  //     while (x < p2.x) {
  //       indices.push(i);
  //       vertices.push_point(*new Point(x, y));
  //       x += step;
  //       i++;
  //     }
  //   } else {
  //     if (p1.x > p2.x) {
  //       swap(&p1.x, &p2.x);
  //     }
  //     if (p1.y > p2.y) {
  //       swap(&p1.y, &p2.y);
  //     }
  //     y = p1.y;
  //     x = p1.x;
  //     m = (p2.y - p1.y) / (p2.x - p1.x);
  //     b = p1.y - m * p1.x;
  //     while (x < p2.x) {
  //       y = p1.y + m * (x - p1.x);
  //       indices.push(i);
  //       vertices.push_point(*new Point(x, y));
  //       x += step;
  //       i++;
  //     }
  //     // while (y < p2.y) {
  //     //  x = (y - b) / m;
  //     //  indices.push(i);
  //     //  vertices.push_point(*new Point(x, y));
  //     //  y += step;
  //     //  i++;
  //     //}
  //   }
  // }

  static void renderNaiveLine(Buffer<T> &indices, Buffer<E> &vertices, Point p1,
                              Point p2) {
    int i = 0;
    float dy = p2.y - p2.y;
    float dx = p2.x - p1.x;
    float m, y, x;
    if (std::abs(dx) >= std::abs(dy)) {
      // line is horizontal like
      if (p1.x > p2.x) {
        swap(&p1, &p2);
      }
      m = dy / dx;
      y = p1.y;
      x = p1.x;
      while (x < p2.x) {
        indices.push(i);
        vertices.push_point(*new Point(x, y));
        y += m;
        x += step;
        i++;
      }
    } else {
      if (p1.y > p2.y) {
        swap(&p1, &p2);
      }
      m = dx / dy;
      y = p1.y;
      x = p1.x;
      while (y <= p2.y) {
        indices.push(i);
        vertices.push_point(*new Point(x, y));
        x += m;
        y += step;
        i++;
      }
    }
  }

private:
  template <typename P> static void swap(P *p1, P *p2) {
    P temp = *p1;
    *p1 = *p2;
    *p2 = temp;
  }
};
#endif
